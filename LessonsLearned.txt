Lessons Learned
--
Factories
	Switching and Type Parameters
		- When trying to determine what to return as a factory method based on a switchable value (e.g. ImportFileTypeId), all possible return classes should implement the same interface or abstract classes
		- The introduction of a type parameter can break this, e.g. a TransactionWriter class that requires a type parameter in order to make the lower level functionality work will not allow the factory method to work.
			- MonzoTransactionWriter -> TransactionWriter<MonzoTransaction> -> BulkWriter<T>	
			- The BulkWriter requires a type parameter to determine all the details for bulk copying data to a SQL table
		The Fix: 
			- MonzoTransaction and SantanderTransaction implemented the ITransaction interface
			- TransactionWriter no longer required a type parameter itself and instead passed ITransaction as a type parameter into BulkWriter, this way we can create a method that returns a TransactionWriter class, with MonzoTransactionWriter and SantanderTransactionWriter using it as a based
			- This then affected the BulkWriter class as it was now seeing the empty ITransaction instead of the actual class underneath. This needed an additional check in it's ConvertSourceToDataTable method where if T is in fact an interface, then take the type from the first record of the IEnumerable passed in to the method. This is somewhat inelegant but was a quick fix to get the job done.

Reading CSV Files
	ODBC
		- I'd gone down this route as I intended all files that were to be imported would be CSV files therefore only needed one delimiter.
		- I'd also specified in ImportFileType the concept of a ColumnDelimiter so that this could be built upon in the future.
		- It turns out the Santander file is semi-colon delimited rather than comma delimited which makes things awkward.
		- It's not possible to specify a specific delimiter in the ODBC connection string (i had assumed it was)
			- schema.ini files could be used but would make things messy
		The Fix:
			- No current fix for this except for converting the Santander file to a comma delimited file
			- schena.ini files could be investigated
			- ODBC Connections could be avoided altogether and the System.IO namespace could be utilised:
				- File.ReadAll
				- string.Split - can then specify specific delimiter
				- Might be interesting to see the performance differences between the two.
				- Would remove the need for any non-database connections
				
Connection Strings
	Building
		- There are specific connection string builder classes (OdbcConnectionStringBuilder, SqlConnectionStringBuilder etc). These can help split up the definition of a connection string
		- This could go hand in hand with extension methods and allow more flexibility in building a connection string to begin with
		- This would create some complexity when it comes to storage
	Storing
		- Hard-coding provides no flexibility at all.
		- app.config is better but not as flexible as it could be
		- separate file for storage is preferable, which with it's own format could solve the complexity problems of the builders
	
	